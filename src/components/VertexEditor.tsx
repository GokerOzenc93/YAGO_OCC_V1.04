import React, { useEffect, useState } from 'react';
import * as THREE from 'three';
import { useThree } from '@react-three/fiber';
import { getBoxVertices, getReplicadVertices } from './VertexEditorService';

interface VertexEditorProps {
  shape: any;
  isActive: boolean;
  onVertexSelect: (index: number | null) => void;
  onDirectionChange: (direction: 'x+' | 'x-' | 'y+' | 'y-' | 'z+' | 'z-') => void;
  onOffsetConfirm: (vertexIndex: number, direction: 'x+' | 'x-' | 'y+' | 'y-' | 'z+' | 'z-', offset: number) => void;
}

const VertexPoint: React.FC<{
  position: THREE.Vector3;
  index: number;
  isHovered: boolean;
  isSelected: boolean;
  onClick: (e: any) => void;
  onContextMenu: (e: any) => void;
  onPointerOver: () => void;
  onPointerOut: () => void;
  scale: number;
}> = ({ position, index, isHovered, isSelected, onClick, onContextMenu, onPointerOver, onPointerOut, scale }) => {
  return (
    <mesh
      position={position}
      onClick={onClick}
      onContextMenu={onContextMenu}
      onPointerOver={(e) => {
        e.stopPropagation();
        onPointerOver();
      }}
      onPointerOut={(e) => {
        e.stopPropagation();
        onPointerOut();
      }}
    >
      <sphereGeometry args={[(isSelected ? 8 : 6) * scale, 16, 16]} />
      <meshBasicMaterial color={isHovered ? '#ef4444' : isSelected ? '#f97316' : '#1f2937'} />
    </mesh>
  );
};

const DirectionArrow: React.FC<{
  position: THREE.Vector3;
  direction: 'x+' | 'x-' | 'y+' | 'y-' | 'z+' | 'z-';
  scale: number;
}> = ({ position, direction, scale }) => {
  const getDirectionVector = (): THREE.Vector3 => {
    switch (direction) {
      case 'x+': return new THREE.Vector3(1, 0, 0);
      case 'x-': return new THREE.Vector3(-1, 0, 0);
      case 'y+': return new THREE.Vector3(0, 1, 0);
      case 'y-': return new THREE.Vector3(0, -1, 0);
      case 'z+': return new THREE.Vector3(0, 0, 1);
      case 'z-': return new THREE.Vector3(0, 0, -1);
    }
  };

  const dirVector = getDirectionVector();
  const arrowLength = 50 * scale;
  const endPosition = position.clone().add(dirVector.clone().multiplyScalar(arrowLength));

  const getRotation = (): [number, number, number] => {
    switch (direction) {
      case 'x+': return [0, 0, -Math.PI / 2];
      case 'x-': return [0, 0, Math.PI / 2];
      case 'y+': return [0, 0, 0];
      case 'y-': return [Math.PI, 0, 0];
      case 'z+': return [Math.PI / 2, 0, 0];
      case 'z-': return [-Math.PI / 2, 0, 0];
    }
  };

  const curve = new THREE.LineCurve3(position, endPosition);
  return (
    <group>
      <mesh>
        <tubeGeometry args={[curve, 8, 3 * scale, 4]} />
        <meshBasicMaterial color="#ef4444" />
      </mesh>
      <mesh position={endPosition} rotation={getRotation()}>
        <coneGeometry args={[4 * scale, 10 * scale, 8]} />
        <meshBasicMaterial color="#ef4444" />
      </mesh>
    </group>
  );
};

const DirectionSelector: React.FC<{
  position: THREE.Vector3;
  onDirectionSelect: (direction: 'x+' | 'x-' | 'y+' | 'y-' | 'z+' | 'z-') => void;
  scale: number;
}> = ({ position, onDirectionSelect, scale }) => {
  const directions: Array<'x+' | 'x-' | 'y+' | 'y-' | 'z+' | 'z-'> = ['x+', 'x-', 'y+', 'y-', 'z+', 'z-'];

  const getDirectionVector = (dir: 'x+' | 'x-' | 'y+' | 'y-' | 'z+' | 'z-'): THREE.Vector3 => {
    switch (dir) {
      case 'x+': return new THREE.Vector3(1, 0, 0);
      case 'x-': return new THREE.Vector3(-1, 0, 0);
      case 'y+': return new THREE.Vector3(0, 1, 0);
      case 'y-': return new THREE.Vector3(0, -1, 0);
      case 'z+': return new THREE.Vector3(0, 0, 1);
      case 'z-': return new THREE.Vector3(0, 0, -1);
    }
  };

  const getColor = (dir: string): string => {
    if (dir.startsWith('x')) return '#ef4444';
    if (dir.startsWith('y')) return '#22c55e';
    return '#3b82f6';
  };

  const getRotation = (dir: 'x+' | 'x-' | 'y+' | 'y-' | 'z+' | 'z-'): [number, number, number] => {
    switch (dir) {
      case 'x+': return [0, 0, -Math.PI / 2];
      case 'x-': return [0, 0, Math.PI / 2];
      case 'y+': return [0, 0, 0];
      case 'y-': return [Math.PI, 0, 0];
      case 'z+': return [Math.PI / 2, 0, 0];
      case 'z-': return [-Math.PI / 2, 0, 0];
    }
  };

  return (
    <group>
      {directions.map((dir) => {
        const dirVector = getDirectionVector(dir);
        const arrowLength = 60 * scale;
        const endPosition = position.clone().add(dirVector.clone().multiplyScalar(arrowLength));
        const color = getColor(dir);

        const curve = new THREE.LineCurve3(position, endPosition);
        return (
          <group key={dir}>
            <mesh>
              <tubeGeometry args={[curve, 8, 3 * scale, 4]} />
              <meshBasicMaterial color={color} transparent opacity={0.8} />
            </mesh>
            <mesh
              position={endPosition}
              rotation={getRotation(dir)}
              onClick={(e) => {
                e.stopPropagation();
                onDirectionSelect(dir);
              }}
            >
              <coneGeometry args={[8 * scale, 16 * scale, 8]} />
              <meshBasicMaterial color={color} />
            </mesh>
          </group>
        );
      })}
    </group>
  );
};

export const VertexEditor: React.FC<VertexEditorProps> = ({
  shape,
  isActive,
  onVertexSelect,
  onDirectionChange,
  onOffsetConfirm
}) => {
  const { viewport } = useThree();
  const scaleFactor = Math.max(0.3, Math.min(1, viewport.width / 30));

  const [hoveredIndex, setHoveredIndex] = useState<number | null>(null);
  const [selectedIndex, setSelectedIndex] = useState<number | null>(null);
  const [currentDirection, setCurrentDirection] = useState<'x+' | 'x-' | 'y+' | 'y-' | 'z+' | 'z-' | null>(null);
  const [showDirectionSelector, setShowDirectionSelector] = useState(false);

  useEffect(() => {
    if (!isActive) {
      setHoveredIndex(null);
      setSelectedIndex(null);
      setCurrentDirection(null);
      setShowDirectionSelector(false);
    }
  }, [isActive]);

  const [vertices, setVertices] = useState<THREE.Vector3[]>([]);
  const [modifiedVertices, setModifiedVertices] = useState<THREE.Vector3[]>([]);

  useEffect(() => {
    const loadVertices = async () => {
      console.log('ðŸ” VertexEditor loadVertices called:', {
        isActive,
        hasShape: !!shape,
        hasParameters: !!shape?.parameters,
        shapeType: shape?.type,
        hasReplicadShape: !!shape?.replicadShape,
        dimensions: shape?.parameters ? {
          w: shape.parameters.width,
          h: shape.parameters.height,
          d: shape.parameters.depth
        } : null
      });

      if (!isActive || !shape.parameters) {
        console.log('âš ï¸ VertexEditor: inactive or no parameters');
        return;
      }

      let baseVerts: THREE.Vector3[] = [];

      if (shape.parameters.scaledBaseVertices && shape.parameters.scaledBaseVertices.length > 0) {
        console.log('ðŸ“ Using pre-computed scaled base vertices...');
        baseVerts = shape.parameters.scaledBaseVertices.map((v: number[]) =>
          new THREE.Vector3(v[0], v[1], v[2])
        );
        console.log(`âœ… Loaded ${baseVerts.length} scaled base vertices`);
      } else if (shape.replicadShape) {
        console.log('ðŸ“ Loading vertices from Replicad shape...');
        baseVerts = await getReplicadVertices(shape.replicadShape);
        console.log(`âœ… Loaded ${baseVerts.length} base vertices from Replicad`);
      } else if (shape.type === 'box') {
        console.log('ðŸ“¦ Loading vertices from box parameters...');
        baseVerts = getBoxVertices(
          shape.parameters.width,
          shape.parameters.height,
          shape.parameters.depth
        );
        console.log(`âœ… Loaded ${baseVerts.length} base vertices from box`);
      }

      console.log('ðŸ“ Setting base vertices:', baseVerts);
      setVertices(baseVerts);

      const modified = baseVerts.map((vertex, index) => {
        if (shape.vertexModifications) {
          const mod = shape.vertexModifications.find((m: any) => m.vertexIndex === index);
          if (mod && mod.newPosition) {
            console.log(`âœ“ Applying vertex ${index} modification:`, {
              base: [vertex.x.toFixed(1), vertex.y.toFixed(1), vertex.z.toFixed(1)],
              modified: [mod.newPosition[0].toFixed(1), mod.newPosition[1].toFixed(1), mod.newPosition[2].toFixed(1)]
            });
            return new THREE.Vector3(
              mod.newPosition[0],
              mod.newPosition[1],
              mod.newPosition[2]
            );
          }
        }
        return vertex.clone();
      });

      console.log(`âœ… Computed ${modified.length} modified vertex positions`);
      setModifiedVertices(modified);
    };

    loadVertices();
  }, [isActive, shape, shape.parameters?.width, shape.parameters?.height, shape.parameters?.depth, shape.replicadShape, shape.vertexModifications]);

  console.log('ðŸŽ¨ VertexEditor render:', {
    isActive,
    hasParameters: !!shape?.parameters,
    verticesLength: vertices.length,
    willRender: isActive && shape?.parameters && vertices.length > 0
  });

  if (!isActive || !shape.parameters || vertices.length === 0) {
    console.log('âŒ VertexEditor not rendering - conditions not met');
    return null;
  }

  const handleVertexClick = (index: number, e: any) => {
    e.stopPropagation();

    if (selectedIndex === index && currentDirection) {
      setShowDirectionSelector(true);
      console.log(`ðŸ”„ Change direction for vertex ${index}`);
    } else {
      setSelectedIndex(index);
      setCurrentDirection(null);
      setShowDirectionSelector(true);
      onVertexSelect(index);
      console.log(`âœ“ Vertex ${index} selected - Choose direction`);
    }
  };

  const handleDirectionSelect = (direction: 'x+' | 'x-' | 'y+' | 'y-' | 'z+' | 'z-') => {
    setCurrentDirection(direction);
    setShowDirectionSelector(false);
    onDirectionChange(direction);
    console.log(`âœ“ Direction ${direction} selected - Right-click to confirm`);
  };

  const handleVertexRightClick = (index: number, e: any) => {
    e.stopPropagation();
    if (selectedIndex === index && currentDirection) {
      console.log(`âœ“ Confirmed - Waiting for terminal input for vertex ${index} (${currentDirection})`);
      (window as any).pendingVertexEdit = true;
    }
  };

  const handleVertexDoubleClick = (index: number, e: any) => {
    e.stopPropagation();
    if (selectedIndex === index && currentDirection) {
      setShowDirectionSelector(true);
      setCurrentDirection(null);
      console.log(`ðŸ”„ Change direction for vertex ${index}`);
    }
  };

  console.log('âœ¨ VertexEditor rendering with:', {
    modifiedVerticesCount: modifiedVertices.length,
    shapePosition: shape.position,
    firstVertex: modifiedVertices[0]
  });

  return (
    <group
      position={[shape.position[0], shape.position[1], shape.position[2]]}
      rotation={[shape.rotation[0], shape.rotation[1], shape.rotation[2]]}
      scale={[shape.scale[0], shape.scale[1], shape.scale[2]]}
    >
      {modifiedVertices.map((vertex, index) => {
        console.log(`ðŸ”´ Rendering vertex ${index}:`, vertex);
        return (
          <VertexPoint
            key={index}
            position={vertex}
            index={index}
            isHovered={hoveredIndex === index}
            isSelected={selectedIndex === index}
            onClick={(e) => handleVertexClick(index, e)}
            onContextMenu={(e) => handleVertexRightClick(index, e)}
            onPointerOver={() => setHoveredIndex(index)}
            onPointerOut={() => setHoveredIndex(null)}
            scale={scaleFactor}
          />
        );
      })}
      {showDirectionSelector && selectedIndex !== null && (
        <DirectionSelector
          position={modifiedVertices[selectedIndex]}
          onDirectionSelect={handleDirectionSelect}
          scale={scaleFactor}
        />
      )}
      {currentDirection && selectedIndex !== null && !showDirectionSelector && (
        <DirectionArrow
          position={modifiedVertices[selectedIndex]}
          direction={currentDirection}
          scale={scaleFactor}
        />
      )}
    </group>
  );
};
